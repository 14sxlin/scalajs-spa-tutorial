# Scala.js SPA-tutorial


[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/ochrons/scalajs-spa-tutorial?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)

Tutorial for creating a simple Single Page Application with [Scala.js](http://www.scala-js.org/) and [Spray](http://spray.io/).

### Purpose

This project demonstrates typical design patterns and practices for developing SPAs with Scala.js with special focus on building a complete application.
 It started as a way to learn more about Scala.js and related libraries, but then I decided to make it more tutorial-like for the greater good :)

The code covers typical aspects of building a SPA using Scala.js but it doesn't try to be an all-encompassing example for all the things possible with Scala.js.
 Before going through this tutorial, it would be helpful if you already know the basics of Scala.js and have read through the official
 [Scala.js tutorial](http://www.scala-js.org/doc/tutorial.html) and the great e-book [Hands-on Scala.js](http://lihaoyi.github.io/hands-on-scala-js/#Hands-onScala.js)
 by [Li Haoyi (lihaoyi)](https://github.com/lihaoyi).

# Getting started

Fork a copy of the repository and clone it to your computer using Git. Run `sbt` in the project folder and after SBT has completed loading the project,
 start the server with `re-start`. This will compile both the client and server side Scala application, package it and start the server. You can now navigate to
 `localhost:8080` on your web browser to open the Dashboard view. It should look something like this

![dashboard](/../screenshots/screenshots/dashboard.PNG?raw=true)

The application is really simple, containing only two views (Dashboard and Todo) and you can access these by clicking the appropriate item on the menu. The Todo
view looks like this

![todos](/../screenshots/screenshots/todos.png?raw=true)

Now that you have everything up and running, it's time to dive into the details of what makes this application tick. Or if you want to experiment a little
yourself, use the `~fastOptJS` command on SBT prompt and SBT will automatically compile the (client side) application when you modify the source code. Try
changing for example the chart data in `js/Dashboard.scala` and reloading the web page.

# Application structure

The application is divided into three folders: `js`, `jvm` and `shared`. As the names imply, `js` contains the client code for the SPA, `jvm` is the server and
`shared` contains code and resources used by both. If you take a quick look at [`project/build.scala`](project/build.scala) you will notice the use of
`crossProject` to define this Scala.js specific [cross-building](http://www.scala-js.org/doc/sbt/cross-building.html) project structure.

Within each sub-project the usual SBT/Scala directory structure convention is followed.

We'll get to the details of the project build file later on, but let's first take a look at actual client code!

## The Client

As is typical for SPAs the client consists of a single HTML file and a number of supporting resources (JS and CSS). One of these resources is the actual JavaScript
 code generated by Scala.js from the Scala sources. There are two variants of the `index.html` one for fast development and the other (`index-full.html`) for
 a production optimized version. Both are stored under `shared` project so that you can access them not only through the server, but also when doing local
 development with the JS client only (more about this later). All the relevant resources are under the `web` directory to prevent conflicts with other (server)
 resources.

In the `index.html` you'll find the usual HTML things like links to CSS and JS files. As you can see, the `<body>` element is pretty empty, because all the
HTML will be generated by the application itself.

```html
<body onload="SPAMain().main()">
<script src="//cdnjs.cloudflare.com/ajax/libs/react/0.12.1/react-with-addons.min.js"></script>
<script src="js/Chart.min.js"></script>
<script src="js/scalajs-spa-fastopt.js"></script>
</body>
</html>
```

The only external JavaScript references are to [React](http://facebook.github.io/react/) and to a [chart component](http://www.chartjs.org/). The last JavaScript
reference is the compiled application code.

Once the browser has loaded all the resources, it will call the `SPAMain().main()` method defined in the
[`SPAMain.scala`](js/src/main/scala/spatutorial/SPAMain.scala) singleton class. This is the entry point of the application. The class itself is very simple,

```scala
@JSExport("SPAMain")
object SPAMain extends JSApp {
  @JSExport
  def main(): Unit = {
    val baseUrl = BaseUrl(dom.window.location.href.takeWhile(_ != '#'))
    val router = MainRouter.router(baseUrl)

    React.render(router(), dom.document.body)
  }
}
```

The externally accessible classes and functions are annotated with `@JSExport` so the Scala.js compiler knows not to optimize them away and make them available
with those exact names in the global scope.

What `main()` does is simply to create a *router* and instruct React to render it inside the document `<body>` tag.

Now at this point you've seen couple of references to React and might wonder what's it about. [React](http://facebook.github.io/react/) is a JavaScript
library for building user interfaces, developed by Facebook. You might ask "why use a JavaScript library with Scala.js if Scala is so great" and yes,
it might make sense to do a similar library in Scala.js but since it's already there, why not use it. And to sweeten the deal there is a very nice
wrapper for React called [scalajs-react](https://github.com/japgolly/scalajs-react) by [David Barri (japgolly)](https://github.com/japgolly).

There are also other Scals.js libraries available for building SPAs but I wanted to go with React, so that's what we'll use in this tutorial :)

### Routing

A critical feature in a SPA is navigation between "pages" within the application. Of course they are not real pages, since it's a *Single Page* Application,
 but from the user point of view it looks like that. A typical example of a SPA is Gmail where the URL in the browser reflects the state of the application.

Since we are not loading new pages from the server, we cannot use the regular browser navigation but need to provide one ourselves. This is called *routing* and
is provided by many JS frameworks like AngularJS. Scala.js itself is not an application framework so there is no ready made router component provided by it. But
we are lucky to have developers like @japgolly who go through all the pain and suffering to deliver great libraries for the rest of us. In the tutorial I'm using
[`scalajs-react` router](https://github.com/japgolly/scalajs-react/blob/master/extra/ROUTER.md) which nicely integrates with `scalajs-react` and provides a
seamless way to manage routes and navigate between them.

The way it works is that you basically create route components, register them with the router and off it goes binding your components as the URL changes. The
provided examples build all routes within a single class, but in real life we want more modularity. In this tutorial we have a total of *two* modules/routes/views
just to demonstrate how to use the router.

Let's start by defining a `BaseRoute` that also allows the modules to register themselves for the main menu.

```scala
trait BaseRoute extends RoutingRules {
  var menuItems = Vector.empty[RouterMenuItem]

  def registerMenu(item: RouterMenuItem) = menuItems :+= item
}
```

Not much there, since everything interesting comes from `RoutingRules`. Each route component is defined as a trait inside the module's object, like this:

```scala
  trait DashboardRoute extends BaseRoute {
    // create the React component for Dashboard
    val DashboardComponent = ReactComponentB[Router]("Dashboard")
    // ....

    // register the component and store location
    val dashboard: Loc = register(rootLocation(DashboardComponent))

    // register it for the Main Menu
    registerMenu(RouterMenuItem("Dashboard", Icon.dashboard, dashboard))
  }
```

Each route component calls the `register` function to register the route (in this case the root location) and `registerMenu` function to register itself
to the main menu.

The routes are combined in `MainRouter.scala` into a single trait, defining the menu order at the same time.

```scala
// ordering of routes here determines the order in the main menu as well
trait AllRoutes extends Dashboard.DashboardRoute with TODO.TODORoute
```

Finally the actual router is created by extending `AllRoutes`.

The `MainRouter` also provides the base HTML code and the main menu for the application in its `interceptRender` function. SPA tutorial uses Bootstrap CSS to
provide a nice looking layout, but you can use whatever CSS framework you wish just by changing the CSS class definitions.

```scala
  override protected def interceptRender(ic: InterceptionR) = {
    div(
      nav(cls := "navbar navbar-inverse navbar-fixed-top")(
        div(cls := "container")(
          div(cls := "navbar-header")(span(cls := "navbar-brand")("SPA Tutorial")),
          div(cls := "collapse navbar-collapse")(
            ul(cls := "nav navbar-nav")(
              // build a list of registered menu items
              for (item <- menuItems) yield {
                li((ic.loc == item.location) ?= (cls := "active"),
                  ic.router.link(item.location.asInstanceOf[ApprovedPath[P]])(item.icon, " ", item.label))
              }
            )
          )
        )
      ),
      // currently active module is shown in this container
      div(cls := "container")(ic.element)
    )
  }
```

See how the code looks just like HTML, except it's type safe and the IDE provides auto-complete!

Ok, we've got the HTML page defined, menu generated and the active component (Dashboard) within the placeholder, what happens next?

### Dashboard

TODO

### Integrating JavaScript components

TODO

### Todo

TODO

## Server side

TODO

### Autowire and uPickle

TODO


# SBT build definition

TODO

# FAQ

TODO

# What next?

TODO

